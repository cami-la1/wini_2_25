//---------------------------------------------------------------------------

#pragma hdrstop

#include "UPtr_conjunto.h"
#define UPlistaH
//---------------------------------------------------------------------------
#pragma package(smart_init)
 ptr_Clista::ptr_Clista(){
	cant = 0;
	ptrConj = NULL;
 }
bool ptr_Clista::vacio() {
	return cant == 0;
}
int ptr_Clista::cardinal() {
	return cant;
}
int ptr_Clista::ordinal(int e) {
	int c = 0;
	NodoConj* aux = ptrConj;
	while (aux != NULL) {
		c++; // empieza en 1
		if (aux->dato == e) {
			return c;
		}
		aux = aux->sig;
	}
	cout << "Error elemento no encontrado\n";
	return -1; // Devuelve -1 por que no lo encuentra
}
void ptr_Clista::inserta(int e) {
	if (!pertenece(e)) {
		NodoConj* dir = new NodoConj;
		if (dir != NULL) {
			dir->dato = e;
			dir->sig = ptrConj;
			ptrConj = dir;
			cant++;
		}
		else
			cout << "ERROR NO EXISTE ESPACIO EN LA MEMORIA\n";
	}
	else
		cout << "ERROR ELEMENTO YA EXISTE\n";
}
NodoConj* ptr_Clista::anterior(NodoConj *p) {
	if (this->vacio()) {
	}
	else if (p == ptrConj) {
	}
	else {
		NodoConj* x = ptrConj;
		NodoConj* ant = NULL;
		while (x != NULL) {
			if (x == p) {
				return ant;
			}
			ant = x;
			x = x->sig;
		}
	}
}
NodoConj* ptr_Clista::localiza(int e) {
	NodoConj* x = ptrConj;
	while (x != NULL) {
		if (x->dato == e)
			return x;
		x = x->sig;
	}
	return NULL;
}
void ptr_Clista::suprime(int e) {
	NodoConj* p = localiza(e);
	if (cant == 0) {
		return;
	}
	else if (p == ptrConj) {
		NodoConj* x = ptrConj;
		ptrConj = ptrConj->sig;
		delete(x);
	}
	else {
		NodoConj* ant = anterior(p);
		ant->sig = p->sig;
		delete(p);
	}
	cant--;
}
bool ptr_Clista::pertenece(int e) {
	NodoConj* x = ptrConj;
	while (x != NULL) {
		if (x->dato == e)
			return true;
		x = x->sig;
	}
	return false;
}
int ptr_Clista::muestrea() {
	if (!vacio()) {
		srand(time(NULL));
		int pos = rand() % cardinal();
		return elemento(pos);
	}
	else
		return 0;
}
int ptr_Clista::elemento(int pos) {
	int c = 0;
	NodoConj* aux = ptrConj;
	while (aux != NULL) {
		if (c == pos)
			return aux->dato;
		c++;
		aux = aux->sig;
	}
	return 0;
}
   void ptr_Clista::Pintado(int posX, int posY, String cad, TColor color, TCanvas *Canvas){
int TamanoCelda = 35;
int TamanoCeldaX = 80;
int TamanoCeldaY = 35;
	//           x1  y1    x2                   y2
	TRect rect(posX,posY,posX+TamanoCeldaX,posY+TamanoCeldaY);
	Canvas->Brush->Color = color;
	Canvas->FillRect(rect);

	Canvas->TextOutW(posX,posY+3,cad);

}
 void ptr_Clista::imprimir(TColor FormColor, TCanvas *Canvas){
	//ptr->imprimir2( FormColor, Canvas,180,800); int TamanoCelda = 35;
  int TamanoCeldaX = 80;
	int TamanoCeldaY = 35;

	int posX = 180;
	int posY = 800;

	if (!vacio()) {
		//DIBUJAMOS CABECERA
		Pintado(posX,posY,"Lista",FormColor,Canvas);
		posY+= TamanoCeldaY;

		NodoConj* x = ptrConj;   int q;

		Pintado(posX,posY,"< ",FormColor,Canvas);
		posX+=40;
		while (x != nullptr) {




				Pintado(posX,posY,IntToStr(x->dato),FormColor,Canvas);
				posX+=80;
				if (x->sig != nullptr) {
					Pintado(posX,posY,",",FormColor,Canvas);
					posX+=40;
				}
				// Imprimimos el último elemento

				x = x->sig;

		}
		Pintado(posX,posY,">",FormColor,Canvas);
		posX+=40;
	}else{
		Pintado(posX,posY,"Lista Vacia",FormColor,Canvas);
		posY+= TamanoCeldaY;
	}
}
