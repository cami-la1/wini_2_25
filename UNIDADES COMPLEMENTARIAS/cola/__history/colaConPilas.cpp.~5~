#pragma hdrstop
#include "ColaConPilas.h"
#pragma package(smart_init)


colaConPilas::colaConPilas(CSmemoria* mem) {
  //	pilaOriginal = new pilaM(mem);
		pilaOriginal = new pilav();
}
bool colaConPilas::vacia() {
    return pilaOriginal->Vacia();
}
void colaConPilas::meter(int valor) {
	pilaOriginal->Meter(valor);
}
bool colaConPilas::sacar(int& valor) {
    if (pilaOriginal->Vacia()) return false;
    pilav aux;
    int temp;
    // Paso 1: pasar todo a auxiliar
    while (!pilaOriginal->Vacia()) {
        dir tempDir;
        pilaOriginal->Sacar(tempDir);
        temp = tempDir;
        aux.Meter(temp);
    }
    // Paso 2: sacar el primer ingresado (último en aux)
    aux.Sacar(temp);
    valor = temp;
    // Paso 3: devolver lo restante a pilaOriginal
    while (!aux.Vacia()) {
        aux.Sacar(temp);
        pilaOriginal->Meter(temp);
    }
    return true;
}

String colaConPilas::imprimirComoCola() {
	String resultado = "[";
	for (int i = 1; i <= pilaOriginal->tope; i++) {
		resultado += IntToStr(pilaOriginal->elementos[i]);
		if (i < pilaOriginal->tope) resultado += ", ";
	}
	resultado += "]";
	return resultado;
}

void colaConPilas::imprimir(TColor color, TCanvas* canvas) {
	const int xInicio = 600;
	const int y = 600;

	String representacion = imprimirComoCola();

	canvas->Font->Color = clBlack;
	canvas->Brush->Color = color;
	canvas->TextOutW(xInicio, y, "Cola: " + representacion);

	if (!pilaOriginal->Vacia()) {
		canvas->TextOutW(xInicio - 80, y + 20, "Final ->");
		canvas->TextOutW(xInicio + representacion.Length() * 7 + 40, y + 20, "<- Frente");
	} else {
		canvas->TextOutW(xInicio, y + 20, "Cola vacía");
	}
}
