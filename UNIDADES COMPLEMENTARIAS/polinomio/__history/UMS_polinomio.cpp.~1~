//---------------------------------------------------------------------------

#pragma hdrstop

#include "UMS_polinomio.h"
#include "UFormmemoria.h"
#include "Umemoria.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
polinomioM::polinomioM(){
crear();
}  void  polinomioM::crear(){
  nt=0;   ptrp=NULO;
}
 polinomioM::polinomioM( CSmemoria* m){
 ;
 Cm= m;  crear();
 }
  int polinomioM::BuscarExponente(int Exp) {
		   int Dir = ptrp;   int x;

		   if (Dir != nulo) { // assuming nulo is a constant defined to represent null or -1
			   int dirEx = nulo; // assuming nulo is a constant defined to represent null or -1
			   while ((Dir != nulo) && (dirEx == nulo)) {

				   if (Cm->obtenerDato(Dir, "->exp")== Exp)
					   dirEx = Dir;
				   Dir = Cm->obtenerDato(Dir, "->sig");
			   }
			   return dirEx;
		   } else return nulo;
  }


	
  int  polinomioM::BuscarTerminoN(int T){
      int Dir = ptrp;
    if (Dir != nulo) { // assuming nulo is a constant defined to represent null or -1
        int dirTer = nulo; // assuming nulo is a constant defined to represent null or -1
		int Nt = 0;
        while ((Dir != nulo) && (dirTer == nulo)) { // assuming nulo is a constant defined to represent null or -1
            Nt = Nt + 1;
			if (Nt == T) {
                dirTer = Dir;
            }
			Dir = Cm->obtenerDato(Dir, "->sig");
        }
		return dirTer;


  } else return nulo;
  }
  bool polinomioM::EsCero(){
  return (nt==0);
  }
   int polinomioM::Grado(){
      int Dir = ptrp;
    if (Dir != nulo) { // assuming nulo is a constant defined to represent null or -1
		int MaxG = Cm->obtenerDato(Dir, "->exp");
		while (Dir != nulo) { // assuming nulo is a constant defined to represent null or -1
			if (Cm->obtenerDato(Dir, "->exp") > MaxG) {
				MaxG = Cm->obtenerDato(Dir, "->exp");
			}
			Dir = Cm->obtenerDato(Dir, "->sig");
        }
		return MaxG;
	} else return nulo;
   }
  int polinomioM::coeficiente(int Exp){
   int Dir = BuscarExponente(Exp);
    if (Dir != nulo) { // assuming nulo is a constant defined to represent null or -1
		return Cm->obtenerDato(Dir, "->coef");
	} else return nulo;
}
void polinomioM::AsignarCoeficiente(int coef, int exp) {
    int Dir = BuscarExponente(exp);
    if (Dir != nulo) { // assuming nulo is a constant defined to represent null or -1
		Cm->poner_dato(Dir, "coef", coef);
		if (coef == 0) {
		Cm->Delete_espacio(Dir);
			// Code to delete node Dir
            // You'll need to implement this depending on how your linked list is structured
        }
    } else {
        throw Exception("No existe ese término"); // exception handling in case the term does not exist
    }
}
 int polinomioM::numero_terminos(){
 return nt;
 }
 void polinomioM::poner_termino(int coef, int exp) {
    int existe = BuscarExponente(exp);
    if (existe == nulo) { // asumiendo que nulo es una constante definida para representar null o -1
		int aux = Cm->new_espacio("coef,exp,sig");
        if (aux != nulo) { // asumiendo que nulo es una constante definida para representar null o -1
			Cm->poner_dato(aux, "->coef", coef);
			Cm->poner_dato(aux, "->exp", exp);
			Cm->poner_dato(aux, "->sig" ,ptrp);
			ptrp = aux;

            nt = nt + 1;
		} else {
			 throw Exception("Error de espacio de memoria"); // manejo de excepciones en caso de que no haya espacio de memoria
		}
	} else {
		int NuevoCoef = Cm->obtenerDato(existe, "->coef") + coef;
		Cm->poner_dato(existe, "->coef", NuevoCoef);
		// Código para eliminar el nodo si NuevoCoef es 0
        // Necesitarás implementar esto dependiendo de cómo esté estructurada tu lista enlazada
    }
}
void polinomioM::poner_en_cero() {
    // Recorre todos los términos del polinomio
    for (int i = 1; i <= numero_terminos(); i++) {
        // Obtiene el exponente del término actual
        int ex = exponente(i);
        // Asigna 0 al coeficiente del término con el exponente obtenido
        AsignarCoeficiente(0, ex);
    }
    // Elimina los términos con coeficiente 0
    // Necesitarás implementar esto dependiendo de cómo esté estructurada tu lista enlazada
}
	int polinomioM::exponente(int nroter){
	  int dir = BuscarTerminoN(nroter);
	if (dir != nulo) { // asumiendo que nulo es una constante definida para representar null o -1
		return Cm->obtenerDato(dir, "->exp");
	}else return nulo;
	}
	void polinomioM::imprimir(TColor FormColor, TCanvas *Canvas){
	Cm->ImprimirPantalla2( FormColor, Canvas,1150,30)  ;

	}
void polinomioM::restar(polinomioM p1, polinomioM p2){
    for (int i = 1; i <= p1.numero_terminos(); i++) {
        int ex = p1.exponente(i);
        int co = p1.coeficiente(ex);
        poner_termino(co, ex);
    }
    for (int i = 1; i <= p2.numero_terminos(); i++) {
        int ex = p2.exponente(i);
        int co = p2.coeficiente(ex) * -1;
        poner_termino(co, ex);
	}
}
void polinomioM::sumar(polinomioM p1, polinomioM p2) {
	// poner polinomio en 0
	 poner_en_cero()   ;
    // necesitarás implementar esto dependiendo de cómo esté estructurada tu lista enlazada
    for (int i = 1; i <= p1.numero_terminos(); i++) {
        int ex = p1.exponente(i);
        int co = p1.coeficiente(ex);
        poner_termino(co, ex);
    }
    for (int i = 1; i <= p2.numero_terminos(); i++) {
        int ex = p2.exponente(i);
        int co = p2.coeficiente(ex);
        poner_termino(co, ex);
    }
}


	void polinomioM::imprimir2(TColor FormColor, TCanvas *Canvas, int x, int y){

	  int pt =ptrp;
	  while (pt!=NULO) {

		  Cm->ImprimirDireccionHorizontal( pt,FormColor,Canvas,x,y);
		  pt=Cm->obtenerDato(pt,"->sig");
		  x=x+20;

	  }

	}
	void polinomioM:: vaciar( ) {
	 int pt = ptrp;
	int prox = NULO;
	while (pt != -1) {
		prox = Cm->obtenerDato(pt, "->sig");
	   Cm->Delete_espacio(pt);
		pt = prox;
	}
		nt=0;
	}

	void polinomioM::poner_termino_ordenado(int coef, int exp) {
	if (coef == 0) return; // Si el coeficiente es 0, no necesitamos agregar el término

    int prev = NULO;
    int curr = ptrp;

    // Buscar la posición correcta para insertar el nuevo término
    while (curr != NULO && Cm->obtenerDato(curr, "->exp") > exp) {
        prev = curr;
        curr = Cm->obtenerDato(curr, "->sig");
    }

    // Si encontramos un término con el mismo exponente, solo actualizamos el coeficiente
    if (curr != NULO && Cm->obtenerDato(curr, "->exp") == exp) {
        int nuevoCoef = Cm->obtenerDato(curr, "->coef") + coef;
        Cm->poner_dato(curr, "->coef", nuevoCoef);
        if (nuevoCoef == 0) {
            // Si el coeficiente resultante es 0, eliminamos el término
            if (prev == NULO) {
                ptrp = Cm->obtenerDato(curr, "->sig");
            } else {
                Cm->poner_dato(prev, "->sig", Cm->obtenerDato(curr, "->sig"));
            }
            Cm->Delete_espacio(curr);
            nt--;
        }
    } else {
        // Si no encontramos un término con el mismo exponente, insertamos un nuevo término
        int nuevo = Cm->new_espacio("coef,exp,sig");
        if (nuevo != NULO) {
            Cm->poner_dato(nuevo, "->coef", coef);
            Cm->poner_dato(nuevo, "->exp", exp);
            if (prev == NULO) {
                Cm->poner_dato(nuevo, "->sig", ptrp);
                ptrp = nuevo;
            } else {
                Cm->poner_dato(nuevo, "->sig", Cm->obtenerDato(prev, "->sig"));
                Cm->poner_dato(prev, "->sig", nuevo);
            }
            nt++;
        } else {
            throw Exception("Error de espacio de memoria"); // Manejo de excepciones en caso de que no haya espacio de memoria
        }
    }
}

